Index: src/core/context/msg_ctx.c
===================================================================
--- src/core/context/msg_ctx.c	(revision 787245)
+++ src/core/context/msg_ctx.c	(working copy)
@@ -124,6 +124,9 @@
     /** are we doing REST now? */
     axis2_bool_t doing_rest;
 
+	/** are we doing json now? */
+	axis2_bool_t doing_json;
+
     /** Rest through HTTP POST? */
     axis2_bool_t do_rest_through_post;
 
@@ -2674,7 +2677,23 @@
     return AXIS2_SUCCESS;
 }
 
+axis2_bool_t AXIS2_CALL
+axis2_msg_ctx_get_doing_json(
+    const axis2_msg_ctx_t *msg_ctx,
+    const axutil_env_t *env)
+{
+	return msg_ctx->doing_json;
+}
 
+AXIS2_EXTERN axis2_status_t AXIS2_CALL
+    axis2_msg_ctx_set_doing_json(axis2_msg_ctx_t *msg_ctx,
+        const axutil_env_t *env,
+        const axis2_bool_t doing_json)
+{
+	msg_ctx->doing_json = AXIS2_TRUE;
+	return AXIS2_SUCCESS;
+}
+
 AXIS2_EXTERN int AXIS2_CALL
 axis2_msg_ctx_get_status_code(
     axis2_msg_ctx_t * msg_ctx,
Index: src/core/transport/http/sender/http_transport_sender.c
===================================================================
--- src/core/transport/http/sender/http_transport_sender.c	(revision 787245)
+++ src/core/transport/http/sender/http_transport_sender.c	(working copy)
@@ -31,6 +31,9 @@
 #include <axiom_soap_fault_detail.h>
 #include <axis2_msg_ctx.h>
 
+
+#include <jaxc_json_writer.h>
+
 #ifdef AXIS2_LIBCURL_ENABLED
 #include "libcurl/axis2_libcurl.h"
 #endif
@@ -191,6 +194,9 @@
     axis2_bool_t write_xml_declaration = AXIS2_FALSE;
     axis2_bool_t fault = AXIS2_FALSE;
 
+	/* JSON */
+	jaxc_json_writer_t* json_badgerfish_writer;
+
     AXIS2_LOG_TRACE(env->log, AXIS2_LOG_SI, 
         "Entry:axis2_http_transport_sender_invoke");
     AXIS2_PARAM_CHECK(env->error, msg_ctx, AXIS2_FAILURE);
@@ -520,6 +526,51 @@
                 /* Finish Rest Processing */
                 
             }
+			else if (AXIS2_TRUE ==  axis2_msg_ctx_get_doing_json(msg_ctx, env))
+			{
+                axiom_node_t *body_node = NULL;
+                axiom_soap_body_t *soap_body = axiom_soap_envelope_get_body(
+                            soap_data_out, env);
+
+                if (!soap_body)
+                {
+                    AXIS2_ERROR_SET(env->error,
+                            AXIS2_ERROR_SOAP_ENVELOPE_OR_SOAP_BODY_NULL,
+                            AXIS2_FAILURE);
+                    AXIS2_LOG_ERROR(env->log, AXIS2_LOG_SI, "%s",
+                            AXIS2_ERROR_GET_MESSAGE(env->error));
+                    axiom_output_free(om_output, env);
+                    om_output = NULL;
+                    xml_writer = NULL;
+                    return AXIS2_FAILURE;
+                }
+                body_node = axiom_soap_body_get_base_node(soap_body, env);
+                if (!body_node)
+                {
+                    axiom_output_free(om_output, env);
+                    om_output = NULL;
+                    xml_writer = NULL;
+                    return AXIS2_FAILURE;
+                }
+                data_out = axiom_node_get_first_element(body_node, env);
+                if (! data_out || axiom_node_get_node_type(data_out, env)
+                        != AXIOM_ELEMENT)
+                {
+                    axiom_output_free(om_output, env);
+                    om_output = NULL;
+                    xml_writer = NULL;
+                    return AXIS2_FAILURE;
+                }
+                axiom_node_serialize(data_out, env, om_output);
+                buffer = (axis2_char_t*)axiom_xml_writer_get_xml(xml_writer, env);
+                buffer_size = axiom_xml_writer_get_xml_size(xml_writer, env);
+				
+				json_badgerfish_writer = json_writer_create(0, env);
+				json_writer_write(json_badgerfish_writer, data_out, env);
+
+				buffer = json_writer_get_converted_xml_str(json_badgerfish_writer, env);
+				buffer_size = strlen(buffer);
+			}
             else
             {
                 axiom_soap_body_t *body = NULL;
Index: src/core/transport/http/util/http_transport_utils.c
===================================================================
--- src/core/transport/http/util/http_transport_utils.c	(revision 787245)
+++ src/core/transport/http/util/http_transport_utils.c	(working copy)
@@ -44,6 +44,11 @@
 #include <axiom_mime_part.h>
 #include <axutil_class_loader.h>
 
+#include <jaxc.h>
+#include <jaxc_badgerfish_reader.h>
+#include <jaxc_node.h>
+#include <jaxc_json_reader.h>
+
 #define AXIOM_MIME_BOUNDARY_BYTE 45
 
 /** Size of the buffer to be used when reading a file */
@@ -189,6 +194,14 @@
     axutil_hash_t * param_map,
     axis2_char_t * method);
 
+/**
+ * JSON Support
+ */
+axis2_char_t *AXIS2_CALL
+axis2_http_transport_utils_get_bytes(
+    const axutil_env_t *env,
+    axutil_stream_t *stream);
+
 static axis2_status_t
 axis2_http_transport_utils_send_attachment_using_file(
     const axutil_env_t * env,
@@ -304,6 +317,13 @@
     axiom_mime_parser_t *mime_parser = NULL;
     axis2_bool_t is_svc_callback = AXIS2_FALSE;
 
+	/**
+	 * JSON Related
+	 */
+	struct jaxc_json_reader_t* json_rdr;
+	axis2_char_t *json_xml_str = NULL; 
+	axis2_bool_t do_json = AXIS2_FALSE;
+	axis2_char_t *json_buff = NULL;
 
     AXIS2_PARAM_CHECK(env->error, msg_ctx, AXIS2_FAILURE);
     AXIS2_PARAM_CHECK(env->error, in_stream, AXIS2_FAILURE);
@@ -585,16 +605,30 @@
                                                                  request_uri));
 
     axis2_msg_ctx_set_server_side(msg_ctx, env, AXIS2_TRUE);
+    char_set_str = axis2_http_transport_utils_get_charset_enc(env, content_type);
+	if (!strstr(content_type, AXIS2_HTTP_HEADER_ACCEPT_JSON))
+	{
+	    char_set_str =
+	        axis2_http_transport_utils_get_charset_enc(env, content_type);
+	    xml_reader =
+	        axiom_xml_reader_create_for_io(env,
+	                                       axis2_http_transport_utils_on_data_request,
+	                                       NULL, (void *) callback_ctx,
+	                                       axutil_string_get_buffer(char_set_str,
+	                                                                env));
+	}
+	else
+	{
+		do_json = AXIS2_TRUE;
+		json_buff = axis2_http_transport_utils_get_bytes(env, in_stream);		
+		json_rdr = json_reader_create(json_buff, 0, env);
+		json_reader_read(json_rdr, env);
+		json_xml_str = json_reader_get_converted_xml_str(json_rdr, env);
+		xml_reader = axiom_xml_reader_create_for_memory(env, 
+				json_xml_str, in_stream->len,
+				axutil_string_get_buffer(char_set_str, env), 0);
+	}
 
-    char_set_str =
-        axis2_http_transport_utils_get_charset_enc(env, content_type);
-    xml_reader =
-        axiom_xml_reader_create_for_io(env,
-                                       axis2_http_transport_utils_on_data_request,
-                                       NULL, (void *) callback_ctx,
-                                       axutil_string_get_buffer(char_set_str,
-                                                                env));
-
     if (!xml_reader)
     {
         return AXIS2_FAILURE;
@@ -679,6 +713,19 @@
         do_rest = AXIS2_TRUE;
         run_as_get = AXIS2_TRUE;
     }
+	else if (do_json)
+	{
+        axiom_soap_body_t *def_body = NULL;
+        axiom_document_t *om_doc = NULL;
+        axiom_node_t *root_node = NULL;
+        soap_envelope = axiom_soap_envelope_create_default_soap_envelope
+                (env, AXIOM_SOAP11);
+        def_body = axiom_soap_envelope_get_body(soap_envelope, env);
+        om_doc = axiom_stax_builder_get_document(om_builder, env);
+        root_node = axiom_document_build_all(om_doc, env);
+        axiom_soap_body_add_child(def_body, env, root_node);
+        /*axis2_msg_ctx_set_doing_rest(msg_ctx, env, AXIS2_TRUE);*/
+	}
     else
     {
         http_error_property = axutil_property_create(env);
@@ -3651,3 +3698,48 @@
     return is_required;
 
 }
+
+axis2_char_t *AXIS2_CALL
+axis2_http_transport_utils_get_bytes(
+    const axutil_env_t *env,
+    axutil_stream_t *stream)
+{
+
+    axutil_stream_t *tmp_stream = NULL;
+    int return_size = -1;
+    axis2_char_t *buffer = NULL;
+
+    AXIS2_ENV_CHECK(env, NULL);
+    AXIS2_PARAM_CHECK(env->error, stream, NULL);
+
+    tmp_stream = axutil_stream_create_basic(env);
+    while (1)
+    {
+        int read = 0;
+        int write = 0;
+
+        char buf[FILE_READ_SIZE];
+        read = axutil_stream_read(stream, env, buf, FILE_READ_SIZE);
+        if (read < 0)
+        {
+            break;
+        }
+        write = axutil_stream_write(tmp_stream, env, buf, read);
+        if (read < (FILE_READ_SIZE - 1))
+        {
+            break;
+        }
+    }
+    return_size = axutil_stream_get_len(tmp_stream, env);
+
+    if (return_size > 0)
+    {
+        buffer = (char *)AXIS2_MALLOC(env->allocator, sizeof(char) *
+                (return_size + 2));
+        return_size = axutil_stream_read(tmp_stream, env, buffer,
+                return_size + 1);
+        buffer[return_size + 1] = '\0';
+    }
+    axutil_stream_free(tmp_stream, env);
+    return buffer;
+}
Index: src/core/util/core_utils.c
===================================================================
--- src/core/util/core_utils.c	(revision 787245)
+++ src/core/util/core_utils.c	(working copy)
@@ -109,6 +109,9 @@
     axutil_param_t *expose_headers_param = NULL;
     axis2_bool_t expose_headers = AXIS2_FALSE;
 
+	/* JSON */
+	axis2_bool_t doing_json = AXIS2_FALSE;
+
     AXIS2_PARAM_CHECK(env->error, in_msg_ctx, NULL);
 
     conf_ctx = axis2_msg_ctx_get_conf_ctx(in_msg_ctx, env);
@@ -219,6 +222,10 @@
     doing_rest = axis2_msg_ctx_get_doing_rest(in_msg_ctx, env);
     axis2_msg_ctx_set_doing_rest(new_msg_ctx, env, doing_rest);
 
+	/* JSON */
+	doing_json =  axis2_msg_ctx_get_doing_json(in_msg_ctx, env);
+    axis2_msg_ctx_set_doing_json(new_msg_ctx, env, doing_json);
+
     doing_mtom = axis2_msg_ctx_get_doing_mtom(in_msg_ctx, env);
     axis2_msg_ctx_set_doing_mtom(new_msg_ctx, env, doing_mtom);
 
Index: include/axis2_msg_ctx.h
===================================================================
--- include/axis2_msg_ctx.h	(revision 787245)
+++ include/axis2_msg_ctx.h	(working copy)
@@ -1808,6 +1808,16 @@
         const axutil_env_t * env,
         axutil_array_list_t * accept_language_record_list);
 
+	AXIS2_EXTERN axis2_bool_t AXIS2_CALL
+	axis2_msg_ctx_get_doing_json(
+		const axis2_msg_ctx_t *msg_ctx,
+		const axutil_env_t *env);
+
+	AXIS2_EXTERN axis2_status_t AXIS2_CALL
+    axis2_msg_ctx_set_doing_json(axis2_msg_ctx_t *msg_ctx,
+        const axutil_env_t *env,
+        const axis2_bool_t doing_json);
+
     /**
      * Gets the Content Language used
      * @param msg_ctx message context
Index: include/axis2_http_transport.h
===================================================================
--- include/axis2_http_transport.h	(revision 787245)
+++ include/axis2_http_transport.h	(working copy)
@@ -730,6 +730,11 @@
 #define AXIS2_HTTP_HEADER_ACCEPT_X_WWW_FORM_URLENCODED "application/x-www-form-urlencoded"
 
     /**
+     * HEADER_ACCEPT_X_WWW_FROM_URLENCODED
+     */
+#define AXIS2_HTTP_HEADER_ACCEPT_JSON "application/json"
+
+    /**
      * HEADER XOP XML
      */
 #define AXIS2_HTTP_HEADER_ACCEPT_XOP_XML AXIOM_MIME_TYPE_XOP_XML
